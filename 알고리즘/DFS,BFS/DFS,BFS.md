# DFS
Depth Frist Search로 깊이 우선 탐색이라 부른다. 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.

<br>

## 그래프
<br>

* 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
* 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식

| |0|1|2|
|------|---|---|---|
|0|0|7|5|
|1|7|0|무한|
|2|5|무한|0|

인접행렬 방식은 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식이다. 연결된 그래프를 표로 나타내면 위와 같다. 위와 같은 연결 그래프가 있을 때, 2차원 리스트로 구현하면 다음과 같다.

```python
INF = 999999999 # 무한의 비용 선언
graph = [
  [0, 7, 5],
  [7, 0, INF],
  [5, INF, 0]
]
print(graph)
# [[0, 7, 5], [7, 0, 999999999], [5, 999999999, 0]]
```

인접 리스트 방식은 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다.

```python
graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장(노드 ,거리)
graph[0].append((1,7))
graph[0].append((2,5))

# 노드 1에 연결된 노드 정보 저장(노드, 거리)
graph[1].append((0,7))

# 노드 2에 연결된 노드 정보 저장(노드, 거리)
graph[2].append((0,5))

print(graph)
#[[(1, 7), (2, 5)], [(0, 7)], [(0, 5)]]
```

두 방식의 차이점은 다음과 같다.

메모리 측면에서 보면 '인접 행렬'은 모든 관계를 저장하므로 노드 개수가 많을 수록 메모리가 낭비된다. 반면 '인접 리스트'는 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다.

하지만 이와 같은 속성때문에 '인접 리스트' 방식은 연결된 데이터를 하나씩 확인해야 하므로 '인접 행렬' 방식에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다.

<br>
다시 DFS 알고리즘으로 돌아와, DFS의 동작 과정은 다음 단계를 거친다.

<br>

1. 탐색 시작 노드를 스택에 삽입 후 방문 처리
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 삽입 후 방문 처리, 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 제거
3. 2번의 과정을 더이상 수행 할 수 없을 때까지 반복

<br>

```python
def dfs(graph, v, visited):
  # 현재 노드를 방문 처리
  visited[v] = True
  print(v, end=' ')
  # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
  for i in graph[v]:
    if not visited[i]:
      dfs(graph, i, visited)

# 2차원 리스트 - 각 노드가 연결된 정보
graph = [
  [],
  [2,3,8],
  [1,7],
  [1,4,5],
  [3,5],
  [3,4],
  [7],
  [2,6,8],
  [1,7]
]

# 방문 정보를 기록할 리스트
visited = [False] * 9

# DFS 호출
dfs(graph, 1, visited) # 1 2 7 6 8 3 4 5

```

깊이 우선 탐색 알고리즘 DFS는 스택 자료구조에 기초해 구현이 간단하다. 실제로 스택을 사용하지 않아도 되고, 탐색하는데 데이터가 N개인 경우 O(N)의 시간이 소요된다는 특징이 있다.

<br>

# BFS
Breadth First Search로 너비 우선 탐색이라고 한다. 가까운 노드부터 탐색을 하는 알고리즘이다. BFS 구현에서는 선입선출 방식의 큐 자료구조를 이용한다. 인접한 노드를 반복적으로 큐에 넣고 자연스럽게 먼저 들어온 것이 나가게 되는 구조를 통해 인접한 노드부터 탐색을 하게 된다.

BFS 동작 방식은 다음과 같다.

<br>

1. 탐색 시작 노드를 큐에 삽입 후 방문 처리
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입 후 방문 처리
3. 2번 과정을 더이상 수행 할 수 없을 때까지 반복

DFS에서 사용한 2차원 리스트를 BFS를 통해 탐색하면 다음과 같다.

```python
from collections import deque

# BFS 메서드 정의


def bfs(graph, start, visited):
    # 큐(Queue)구현을 위해 dequeue 라이브러리 이용
    queue = deque([start])

    # 현재 노드를 방문 처리
    visited[start] = True

    # 큐가 empty일 때까지 반복
    while queue:
        # 큐에서 하나의 원소를 봅아 출력
        v = queue.popleft()
        print(v, end=' ')
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True


# 2차원 리스트 - 각 노드가 연결된 정보
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

# 방문 정보를 기록할 리스트
visited = [False] * 9

# DFS 호출
bfs(graph, 1, visited)  # 1 2 3 8 7 4 5 6

```

BFS는 큐 자료구조에 기초해 구현이 간단하다. dequeue 라이브러리를 사용하는 것이 좋고, 탐색을 수행하는데 O(N)의 시간이 소요된다. 일반적인 경우 실제 수행 시간은 DFS보다 좋은 편이라고 생각만 해두자.

<br>

## DFS, BFS 정리

| |DFS|BFS|
|---|---|---|
|동작 원리|스택|큐|
|구현 방법|재귀 함수 이용| 큐 자료구조 이용|

