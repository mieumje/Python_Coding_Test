# 구현
## 머릿속에 있는 알고리즘을 정확하고 빠르게 프로그램으로 작성하기
<br>

### 피지컬로 승부하기
<br>
코딩 테스트에서 구현이란 '머릿속에 잇는 알고리즘을 소스코드로 바꾸는 과정'이다. 어떤 문제든 간에 코드를 작성하는 일은 필수이므로 구현 문제 유형은 모든 범위의 코딩 테스트 문제 유형을 포함하는 개념이다.

<br>
알고리즘 문제를 해결할 때, 문제를 읽고서 풀이 방법에 대해 고민한다. 이 과정의 결과로 해결 방법이 떠오르면 바로 정답을 받는가? 그렇지 않다. 고안해 낸 방법을 원하는 프로그래밍 언어로 구현해냈을 때 정답 처리를 받을 수 있다. 따라서 언어의 정확한 문법을 알아야 하고 문제의 요구 사항에 맞추어 코드를 작성해야 한다.

<br>
'구현'유형의 문제는 '풀이를 떠올리는 것은 쉽지만 소스코드로 옮기는 어려운 문제'를 의미한다. 개발할 때 '피지컬이 좋은 사람'이라는 말은 프로그래밍 언어의 문법에 능숙하고 코드 작성 속도가 빠른 사람을 말한다. 문제 풀이를 위한 해답을 찾아 냈지만 제한 시간안에 작성하지 못하면 의미가 없다. 

<br>
대체로 구현하기 어려운 문제는 다음과 같다. 알고리즘은 단순하지만 코드의 길이가 상당한 경우, 특정 소수점 까지 출력해야 하는 경우, 문자열이 주어졌을 때 파싱해야 하는 경우 등이다. 대체로 사소한 조건 설정이 많을수록 구현하기가 까다롭다. 다양한 문제를 풀어 경험치가 높은 사람에게는 쉬울 수 있지만, 초심자의 경우 문법부터 익숙하지 않아 문제가 어렵게 느껴진다.

<br>
고수의 경우가 아니고서 구현 문제를 만나면 당황스러울 수 밖에 없다. 문제를 읽고 풀이의 방향성은 느낄 수 있지만 어떤 것부터 작성해야 하는지 답답하게 느껴지기 때문이다. 가령 순열을 구해야 하는 문제를 접했을 때, 순열에 대해 이해하고 있다면 해답을 떠올리는 것은 쉬울 수 있다. 그러나 파이썬의 itertools와 같은 표준 라이브러리를 모른다면, 일일이 구현해야 한다.

<br>
'이코테 with 파이썬'에서는 '완전 탐색'과 '시뮬레이션' 유형을 모두 '구현' 유형으로 묶어 다룬다. 
<br>

- 완전 탐색 : 모든 경우의 수를 다 계산하는 방법
- 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 직접 수행

<br>

---
## 구현 시 고려해야 할 메모리 제약 사항
C/C++, Java에서 정수형 종류에 따라 범위를 고민해야 하는데, 파이썬에서는 자료형을 지정할 필요가 없고 큰 수의 연산 또한 기본으로 지원해주기 때문에 고민하지 않아도 된다.

<br>

### 파이썬에서 리스트 크기
파이썬에서 여러 개의 변수를 이용할 때는 리스트를 이용한다. 리스트를 이용할 때 코딩 테스트의 메모리 제한을 고려해야 한다. 대체로 코딩 테스트에서는 128~512MB로 메모리를 제한하는데 종종 문제에서 수백만 개 이상의 데이터를 처리해야 하는 문제가 출제된다. 이런 경우에는 메모리 제한을 염두해 두고 코딩해야 한다. 

<br>

|데이터의 개수(리스트의 길이)|메모리 사용량
|------|---|
|1,000|약 4KB|
|1,000,000|약 4MB|
|10,000,000|약 40MB|

파이썬은 구현상의 복잡함이 적은 편이지만 데이터 처리량이 많을 때는 메모리 제한을 고려하도록 한다. 리스트를 여러 개 선언하고 그중에서 크키가 1,000만 이상인 리스트가 있다면 메모리 용량 제한에 걸리는 경우가 있다.

<br>

## 채점 환경
시간 제한이 1초이고, 데이터 개수가 100만 개인 문제가 있다면 시간 복잡도 O(NlogN) 이내의 알고리즘을 이용해 문제를 풀어야 한다. 
### N = 1,000,000일 때 Nlog2N은 약 20,000,000
따라서 알고리즘 문제를 풀 때는 시간 제한과 데이터 개수를 먼저 확인하고 이 문제를 어느 정도의 시간 복잡도의 알고리즘으로 작성해야 풀 수 있을 것인지 예측할 수 있어야 한다.

<br>

## 구현 문제에 접근하는 방법
구현 문제는 대체로 사소한 입력 조건 등을 명시해 주어 문제의 길이가 긴 편이다. 문제 길이가 길어 어렵지 않을까 하는 생각을 하는데, 고차원적인 사고력을 요구하는 문제가 출제되지 않는 편이라 문법에 익숙하다면 오히려 문제는 쉽게 풀릴 수 있다.

<br>

---

## 그리디 알고리즘 예제
<br>

### 상하좌우

<br>

### 문제 설명
여행가 A는 N * N 크기의 정사각형 공간 위에 서 있다. 이 공간은 1 * 1 크기의 정사각형으로 나누어져 있다. 가장 왼 쪽 위 좌표는 (1,1)이며, 가장 오른쪽 아래 좌표는 (N,N)에 해당한다. 여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1,1)이다. 우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여 있다.

계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀 있다. 각 문자의 의미는 다음과 같다.

- L : 왼쪽으로 한 칸 이동
- R : 오른쪽으로 한 칸 이동
- U : 위로 한 칸 이동
- D : 아래로 한 칸 이동

이때 여행가 A가 N * N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다. 예를 들어 (1,1)의 위치에서 L 혹은 U를 만나면 무시된다. 

N = 5이고, 움직임이 R, R, R, U, D, D인 경우를 살펴보자.
6개의 명렁에 따라서 여행가가 움직이게 되는 위치는 순서대로 (1,1), (1,2), (1,3), (1,4), (2,4), (3,4)가 된다. 최종적으로 A가 도착하게 되는 곳의 좌표는 (3,4)이다. 계획서가 주어졌을 때 여행가 A가 최종적으로 도착할 지점의 좌표를 출력하는 프로그램을 작성하시오.

<br>

### 입력 조건
- 첫째 줄에 공간의 크기를 나타내는 N이 주어진다. (1 <= N <= 100)
- 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어진다. (1 <= 이동 횟수 <= 100)

<br>

### 출력 조건
- 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표 (X,Y)를 공백으로 구분하여 출력한다.

<br>

### 입력 예시
- 5
- R R R U D D
### 출력 예시
- 3 4

<br>

### 문제 해설

```Python
def solution(N, moves):
    x, y = 1, 1         # 시작 위치
    dx = [0, 0, -1, 1]  # 좌, 우, 상, 하
    dy = [-1, 1, 0, 0]  # 좌, 우, 상, 하
    move_type = ['L', 'R', 'U', 'D']

    for move in moves:
        for j in range(4):
            if move == move_type[j]:
                nx = x + dx[j]
                ny = y + dy[j]
        if nx < 1 or ny < 1 or nx > N or ny > N:    # x,y 좌표가 N*N을 벗어난 경우
            continue
        x = nx
        y = ny
    return x, y


N = int(input())
moves = input().split()
x, y = solution(N, moves)


print(x, y)
```