# 다이나믹 프로그래밍(Dynamic Programming)

## 중복되는 연산을 줄이자

컴퓨터 연산 속도에 한계가 있고, 메모리 공간을 사용할 수 있는 데이터 갯수도 한정적이라 많은 제약사항이 따른다. 연산 속도와 메모리 공간을 최대한으로 사용할 수 있는 알고리즘을 작성해야 한다.

특정 문제에 한해서 메모리 공간을 조금 더 사용하는 방법으로 연산 속도를 비약적으로 증가시킬 수 있는 방법이 있는데 대표적으로 '다이나믹 프로그래밍(DP, Dynamic Programming)'이 있다.

### 다이나믹 프로그래밍(Dynamic Programming)의 Dynamic과 동적 할당(Dynamic Allocation)의 Dynamic은 같은 의미인가?

프로그래밍에서의 Dynamic은 '프로그램이 실행되는 도중에'라는 의미를 갖는다. 동적 할당은 프로그램 실행 중에 프로그램에 필요한 메모리를 할당하는 기법이다. DP에서의 Dynamic은 이와 전혀 관련이 없다.

피보나치 수열은 대표적인 DP 예시이다. `피보나치 수열 점화식 : F(n+1)=F(n)+F(n-1)`

```py
def fibo(x):
  if x == 1 or x == 2:
    return 1
  return fibo(x - 1) + fibo(x - 2)

fibo(4)
```

피보나치 수열 점화식을 구현하면 위와 같이 작성할 수 있다. 그러나 n이 커지멸수록 수행 시간이 기하급수적으로 늘어난다. `f(5)`를 구한다고 생각해봐도 `f(3)` 연산을 2번 실행하게 된다. 이처럼 한 번 계산한 것을 다시 호출해 계산하면 수행시간이 늘어날 수 밖에 없다. 매번 계산하도록 하면 문제를 효율적으로 해결할 수 없다. 매번 계산하는 문제를 DP로 해결할 수 있다.

단, 다음 조건을 만족할 때만 DP를 사용할 수 있다.

1. 큰 문제를 작은 문제로 나눌 수 있다.
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

메모이제이은 DP를 구현하는 하나의 방법이다. 한 번 계산한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 가져오는 기법이다. 메모이제이션은 값을 저장하는 방법이므로 캐싱이라고도 한다.

```py
memoization = [0] * 100

def fibo(x):
  if x == 1 or x == 2:
    return 1

  if memoization[x] != 0:
    return memoization[x]

  memoization[x] = fibo(x - 1) +  fibo(x - 2)

  return memoization[x]

fibo(99)
```

이렇게 큰 문제를 해결하기 위해 작은 문제를 호출하는 방법을 `탑다운 방식(Top-Down)`이라고 한다.
반면 단순 반복문을 이용해 작성하는 방식은 작은 문제부터 답을 도출한다고 하여 `바텀업 방식(Bottom-Up)`이라고 말한다.

```py
memoization = [0] * 100

memoization[1] = 1
memoization[2] = 1
n = 99

for i in range(3, n + 1):
  memoization[i] = memoization[i - 1] + memoization[i - 2]
```

DP의 전형적인 형태는 바텀업 방식이다. 바텀업 방식에 사용되는 결과 저장용 리스트는 `DP 테이블`이라 부르고, 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현이다.

DP와 메모이제이션 개념을 혼용하는 경우가 있는데, 메모이제이션과 DP는 별도의 개념이다. 메모이제이션은 이전에 계산도니 결과를 일시적으로 기록해 놓는 넓은 개념을 의미하기 떄문이다.
