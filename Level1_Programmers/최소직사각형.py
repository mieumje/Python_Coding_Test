"""

가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 
하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 
이때의 지갑 크기는 4000(=80 x 50)입니다.

모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 
모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.

"""
def solution(sizes):
    answer = 0
    
    w, h = [], []
    
    for i in sizes: # sizes의 각 원소의 첫번째 원소와 두번째 원소를 비교해 큰 값을 가로에, 작은 값을 세로에 넣는다.
        if i[0] < i[1]:
            w.append(i[1])
            h.append(i[0])
        else:
            w.append(i[0])
            h.append(i[1])
    
    answer = max(w) * max(h) # 가로, 세로 배열의 최대값으로 지갑을 만든다
    return answer

# 제한사항
# sizes의 길이는 1 이상 10,000 이하입니다.
# sizes의 원소는 [w, h] 형식입니다.
# w는 명함의 가로 길이를 나타냅니다.
# h는 명함의 세로 길이를 나타냅니다.
# w와 h는 1 이상 1,000 이하인 자연수입니다.

# 입출력 예
# sizes	                                            result
# [[60, 50], [30, 70], [60, 30], [80, 40]]	        4000
# [[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]]	    120
# [[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]]	    133